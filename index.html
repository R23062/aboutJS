<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【体系的解説】関数型プログラミング: JavaScriptとHaskellによるアプローチの探求</title>
    <link rel="stylesheet" href="main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <header class="hero">
        <div class="container">
            <h1>関数型プログラミングの体系的探求</h1>
            <p>JavaScriptとHaskellを比較し、その設計思想と実践を深く理解する</p>
        </div>
    </header>

    <main class="container">
        <section id="fp-overview" class="animate-on-scroll">
            <h2>1. 関数型プログラミング（FP）とは何か</h2>
            <p>
                関数型プログラミングとは、計算を<strong>数学的な関数の評価</strong>として捉え、<strong>状態の変更や可変データを避ける</strong>ことを中心に据えた宣言的なプログラミングパラダイムです。命令型プログラミングが「どのように（How）」問題を解決するかを逐次的に記述するのに対し、関数型プログラミングは「何を（What）」達成したいかを記述します。
            </p>
            <h3>1.1. 厳密な定義と核心思想</h3>
            <p>
                FPの核心は、<strong>副作用（Side Effect）</strong>を厳格に管理し、プログラムの大部分を<strong>純粋な関数</strong>で構成することにあります。純粋な関数とは、同じ入力に対して常に同じ出力を返し、外部の状態に影響を与えない（あるいは影響されない）関数のことです。この性質は<strong>参照透過性</strong>と呼ばれ、プログラムの動作を予測しやすくし、テストやデバッグ、並行処理を劇的に容易にします。
            </p>
            <h3>1.2. 用途と適性</h3>
            <p>
                状態変化に起因する複雑さを低減できるため、FPは以下のような領域で特に強力です。
            </p>
            <ul>
                <li><strong>データ処理パイプライン:</strong> 大量データの変換、フィルタリング、集計など、一連の処理を関数の合成として表現できます（例: Apache Spark）。</li>
                <li><strong>複雑なUIの状態管理:</strong> ユーザーインタラクションによる状態変化を、一貫性のあるルールで管理するのに適しています（例: React/Reduxアーキテクチャ）。</li>
                <li><strong>並行・並列処理:</strong> データが不変であるため、複数のスレッドが同時にデータにアクセスしても競合状態（Race Condition）が発生せず、安全に並列化できます。</li>
                <li><strong>コンパイラ・DSL（ドメイン固有言語）:</strong> コードの構文解析や変換といった処理は、関数の合成と非常に相性が良いです。</li>
            </ul>
            <h3>1.3. FPが利用できる言語</h3>
            <p>
                FPは特定の言語に限定されるものではなく、多くの言語でその概念がサポートされています。
            </p>
            <ol>
                <li><strong>純粋関数型言語:</strong> Haskell, Elm など。FPの原則を言語仕様レベルで強制します。</li>
                <li><strong>ハイブリッド言語:</strong> Scala, F#, OCaml, Clojure など。FPを主軸としつつ、オブジェクト指向や命令型の機能も併せ持ちます。</li>
                <li><strong>FP機能を備えた言語:</strong> JavaScript/TypeScript, Python, Rust, Swift, Kotlin など。第一級関数や高階関数をサポートし、FPスタイルでのプログラミングが可能です。</li>
            </ol>
        </section>
        <hr>

        <section id="fp-concepts" class="animate-on-scroll">
            <h2>2. 関数型プログラミングの構成要素</h2>
            <p>ここではFPを支える主要な概念を一つずつ取り上げ、JavaScriptとHaskellでのアプローチを比較します。</p>

            <div class="language-logos">
                <img src="javascript-logo.png" alt="JavaScript Logo" class="logo-image-small">
                <img src="haskell-logo.png" alt="Haskell Logo" class="logo-image-small">
            </div>
            <div class="concept">
                <h3>2.1. 純粋性と副作用（参照透過性）</h3>
                <p>
                    プログラムの予測可能性の根幹をなす概念です。純粋な関数は、外部環境から隔離された安全な計算単位となります。
                </p>
                <h4>JavaScriptでのアプローチ: 規律としての純粋性</h4>
                <p>
                    JSでは純粋な関数を書くことは可能ですが、言語はそれを強制しません。副作用は自由に記述でき、純粋性を保つかは開発者の意識に依存します。
                </p>
<pre><code class="language-js">// 純粋な関数: 参照透過性を持つ
const pureAdd = (a, b) => a + b;

// 純粋でない関数: グローバル変数という副作用に依存
let globalModifier = 10;
const impureAdd = (a) => a + globalModifier;

// 純粋でない関数: console.logという副作用を持つ
const logAndReturn = (value) => {
  console.log('Logging value:', value); // 副作用
  return value;
};
</code></pre>
                <h4>Haskellでのアプローチ: デフォルトでの純粋性</h4>
                <p>
                    Haskellでは全ての関数がデフォルトで純粋です。副作用を伴う処理は<code>IO</code>モナドという型で明示的に表現され、純粋な世界から隔離されます。これにより、関数の型シグネチャを見るだけで副作用の有無が判断できます。
                </p>
<pre><code class="language-haskell">-- Int -> Int -> Int という型を持つ純粋な関数
pureAdd :: Int -> Int -> Int
pureAdd a b = a + b

-- Stringを画面に出力するという副作用を持つIOアクション
-- 型シグネチャに `IO` が含まれることで副作用が明示される
logAndReturn :: String -> IO String
logAndReturn value = do
  putStrLn ("Logging value: " ++ value) -- 副作用を伴うIOアクション
  return value                         -- IOコンテキスト内で値を返す
</code></pre>
            </div>

            <div class="concept">
                <h3>2.2. 不変性（Immutability）</h3>
                <p>
                    一度作成したデータ（オブジェクトや配列）を変更しないという原則です。状態を変更する場合は、元のデータのコピーに変更を加えた新しいデータを作成します。これにより、意図しない状態の書き換えを防ぎ、デバッグを容易にします。
                </p>
                <h4>JavaScriptでのアプローチ: 手動での実現</h4>
                <p>
                    <code>const</code>は再代入を防ぐのみで、オブジェクトの内部は変更可能です。不変性を保つにはスプレッド構文などを用いますが、ネストされたオブジェクトは参照がコピーされるだけ（浅いコピー）という罠があります。
                </p>
<pre><code class="language-js">// スプレッド構文によるイミュータブルな更新
const user = { id: 1, name: "Alice" };
const updatedUser = { ...user, name: "Bob" }; // 新しいオブジェクトを作成

// 浅いコピーの問題点: ネストされたオブジェクトは不変性が保たれない
const complexState = { settings: { theme: "dark" } };
const newComplexState = { ...complexState };
newComplexState.settings.theme = "light"; // 元のcomplexStateも変更されてしまう！
console.log(complexState.settings.theme); // "light"
</code></pre>
                <h4>Haskellでのアプローチ: デフォルトでの不変性</h4>
                <p>
                    Haskellでは全てのデータがデフォルトで不変です。変数の再代入という概念自体が存在しません。データ構造は「永続データ構造」として実装されており、更新時には変更箇所のみを新しく生成し、残りは元の構造と効率的に共有するため、パフォーマンスも考慮されています。
                </p>
<pre><code class="language-haskell">-- レコード構文によるイミュータブルな更新
-- dataキーワードで独自の型を定義
data User = User { userId :: Int, userName :: String } deriving (Show)

-- user1を作成
let user1 = User { userId = 1, userName = "Alice" }

-- user1を基に、userNameだけが異なるuser2を"作成"する
-- user1自体は一切変更されない
let user2 = user1 { userName = "Bob" }
-- user2 は User {userId = 1, userName = "Bob"}
</code></pre>
            </div>

            <div class="concept">
                <h3>2.3. 第一級関数と高階関数</h3>
                <p>
                    <strong>第一級関数</strong>とは、関数が変数への代入、引数としての受け渡し、戻り値としての返却など、他の値（数値や文字列など）と同様に扱える性質です。<strong>高階関数</strong>とは、関数を引数に取る、または関数を戻り値として返す関数のことです。これにより、抽象度の高いコードが書けます。
                </p>
                <h4>JavaScriptでのアプローチ: データ操作の基本ツール</h4>
                <p>
                    <code>map</code>, <code>filter</code>, <code>reduce</code>といった配列メソッドは代表的な高階関数で、宣言的なデータ操作の要となります。
                </p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4];
const double = (x) => x * 2;
const isEven = (x) => x % 2 === 0;

// map: 各要素に関数を適用した新しい配列を返す
const doubled = numbers.map(double); // [2, 4, 6, 8]

// filter: 条件を満たす要素だけの新しい配列を返す
const evens = numbers.filter(isEven); // [2, 4]
</code></pre>
                <h4>Haskellでのアプローチ: 制御構造の代替</h4>
                <p>
                    Haskellには命令型の<code>for</code>や<code>while</code>ループは存在せず、データ操作は再帰か高階関数で行うのが基本です。<code>map</code>や<code>filter</code>は言語のコア機能として提供されています。
                </p>
<pre><code class="language-haskell">-- Haskellのmapとfilter
-- 型シグネチャ: map :: (a -> b) -> [a] -> [b]
--             filter :: (a -> Bool) -> [a] -> [a]
let numbers = [1, 2, 3, 4]
let double x = x * 2
let isEven x = x `mod` 2 == 0

let doubled = map double numbers   -- [2, 4, 6, 8]
let evens   = filter isEven numbers -- [2, 4]
</code></pre>
            </div>

            <div class="concept">
                <h3>2.4. カリー化、部分適用、関数合成</h3>
                <p>
                    これらは小さな関数を組み合わせて、より複雑な機能を作るための強力な技法です。
                    <ul>
                        <li><strong>カリー化:</strong> 複数引数を取る関数を、1つの引数を取る関数の連鎖に変換すること。</li>
                        <li><strong>部分適用:</strong> 複数引数関数のうち、いくつかの引数を先に固定して新しい関数を作ること。</li>
                        <li><strong>関数合成:</strong> ある関数の出力を別の関数の入力としてつなげること (f(g(x)))。</li>
                    </ul>
                </p>
                <h4>JavaScriptでのアプローチ: 手動実装のパターン</h4>
                <p>
                    クロージャを利用してカリー化を模倣し、関数合成のためのヘルパー関数を自作するのが一般的です。
                </p>
<pre><code class="language-js">// カリー化と部分適用
const multiply = (a) => (b) => a * b;
const double = multiply(2); // 部分適用により、2倍する関数ができた
console.log(double(10)); // 20

// 関数合成
const compose = (f, g) => (x) => f(g(x));
const add1 = (x) => x + 1;
const add1AndDouble = compose(double, add1); // 最初にadd1、次にdouble
console.log(add1AndDouble(5)); // 12  (double(add1(5)))
</code></pre>
                <h4>Haskellでのアプローチ: 言語レベルのサポート</h4>
                <p>
                    Haskellでは全ての関数がデフォルトでカリー化されています。これにより部分適用が極めて自然に行えます。関数合成には専用の<code>.</code>演算子が用意されています。
                </p>
<pre><code class="language-haskell">-- 全ての関数が自動でカリー化されている
multiply :: Int -> Int -> Int
multiply a b = a * b

-- multiply 2 は自動的に部分適用となり、新しい関数を生成する
let double = multiply 2

-- ghci> double 10
-- 20

-- 関数合成演算子 `.`
add1 :: Int -> Int
add1 x = x + 1

-- (f . g) x は f(g(x)) と同じ
let add1AndDouble = double . add1

-- ghci> add1AndDouble 5
-- 12
</code></pre>
            </div>

             <div class="concept">
                <h3>2.5. 代数的データ型（ADT）とパターンマッチング</h3>
                <p>
                    <strong>代数的データ型</strong>は、既存の型を組み合わせて新しい型を作る仕組みです。「複数の型が同時に存在する」<strong>積型</strong>（タプルやレコード）と、「いずれか一つの型である」<strong>和型</strong>（バリアント型）があります。これにより、ドメインのモデルを正確かつ安全に表現できます。<strong>パターンマッチング</strong>は、ADTの構造に応じて処理を分岐させる強力な構文です。
                </p>
                <h4>JavaScriptでのアプローチ: 模倣と限界</h4>
                <p>
                    JSにはADTが組み込まれていません。オブジェクトのプロパティやTypeScriptのUnion型などを用いて模倣しますが、コンパイラによる網羅性チェック（全ての可能性を尽くしているか）は得られません。
                </p>
<pre><code class="language-js">// 和型を模倣する
// { type: 'Success', data: '...' } または { type: 'Failure', error: '...' }
function handleResult(result) {
  switch (result.type) {
    case 'Success':
      return `Data received: ${result.data}`;
    case 'Failure':
      return `Error occurred: ${result.error}`;
    // defaultケースを忘れると、新しいtypeが追加された時にバグになる
  }
}
</code></pre>
                <h4>Haskellでのアプローチ: 中核機能としてのADT</h4>
                <p>
                    HaskellではADTが言語の中核です。<code>data</code>キーワードで簡単に定義でき、<code>case</code>式によるパターンマッチングでは、コンパイラが全てのパターンを網羅しているかチェックしてくれます。これにより、実行時エラーの多くをコンパイル時に排除できます。
                </p>
<pre><code class="language-haskell">-- `Either a b` はHaskellに標準で存在する代表的な和型
-- data Either a b = Left a | Right b
-- Leftは失敗、Rightは成功を表す慣習

handleResult :: Either String Int -> String
handleResult result =
  case result of
    Right dataVal -> "Data received: " ++ show dataVal
    Left errorMsg -> "Error occurred: " ++ errorMsg
-- ここでLeftかRightのどちらかのパターンを書き忘れると、コンパイラが警告を出す
</code></pre>
            </div>

        </section>
        <hr>

        <section id="summary-table" class="animate-on-scroll">
            <h2>3. まとめ: 設計思想の比較</h2>
            <p>
                JavaScriptは、Webのエコシステムの中で実践的な要求に応えながら、FPの強力なパターンを選択的に取り入れることで進化してきました。そのアプローチは柔軟で実用主義的です。
                <br>
                一方、Haskellは計算機科学の理論を背景に、プログラムの正しさと表現力を最大化するためにFPの原則を徹底しています。そのアプローチは厳格で理論的です。
            </p>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>概念 / 特徴</th>
                            <th>JavaScript アプローチ</th>
                            <th>Haskell アプローチ</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>基本思想</strong></td>
                            <td>柔軟なマルチパラダイム。FPは選択肢の一つ。</td>
                            <td>純粋関数型。FPが言語の基盤。</td>
                        </tr>
                        <tr>
                            <td><strong>純粋性</strong></td>
                            <td>規律として実践。副作用は制限されない。</td>
                            <td>デフォルトで強制。副作用は型システム(<code>IO</code>)で管理。</td>
                        </tr>
                        <tr>
                            <td><strong>不変性</strong></td>
                            <td>手動で実現。浅いコピーに注意が必要。</td>
                            <td>デフォルトで不変。永続データ構造で効率化。</td>
                        </tr>
                        <tr>
                            <td><strong>型システム</strong></td>
                            <td>動的型付け。(TypeScriptで静的型付けを追加)</td>
                            <td>強力な静的型付けと型推論（Hindley-Milner）。</td>
                        </tr>
                        <tr>
                            <td><strong>データ構造の表現</strong></td>
                            <td>オブジェクトと配列。ADTは模倣する。</td>
                            <td>代数的データ型(ADT)とパターンマッチングが中核。</td>
                        </tr>
                        <tr>
                            <td><strong>カリー化</strong></td>
                            <td>手動で実装するデザインパターン。</td>
                            <td>言語の基本機能。全関数が自動でカリー化。</td>
                        </tr>
                        <tr>
                            <td><strong>関数合成</strong></td>
                            <td>ヘルパー関数で実現するパターン。</td>
                            <td>専用の <code>.</code> 演算子として提供。</td>
                        </tr>
                        <tr>
                            <td><strong>イテレーション</strong></td>
                            <td>命令型ループ(<code>for</code>)と高階関数(<code>map</code>)が混在。</td>
                            <td>再帰と高階関数が基本。</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="reference-links animate-on-scroll">
            <h2>参考リンク</h2>
            <ul>
                <li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN Web Docs: JavaScript</a></li>
                <li><a href="https://www.haskell.org/" target="_blank" rel="noopener noreferrer">Haskell Language Official Website</a></li>
                <li><a href="http://learnyouahaskell.com/chapters" target="_blank" rel="noopener noreferrer">Learn You a Haskell for Great Good! (やさしいHaskell入門)</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>本コンテンツの作成時間（HTML/CSS/JavaScriptの設計・実装を含む）：約6時間</p>
        </div>
    </footer>
    
    <button id="back-to-top-btn" title="トップへ戻る">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
    </button>
    
    <script src="script.js"></script>
</body>
</html>
